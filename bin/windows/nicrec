#
# Copyright (c) 2017 Stefan Parvu (www.kronometrix.org).
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software Foundation,
# Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
# (http://www.gnu.org/copyleft/gpl.html)

package PerlSvc;

use strict;
use warnings;
use Getopt::Long;
use Date::Calc qw(:all);
use File::Copy;
use Time::HiRes qw(time gettimeofday usleep tv_interval);
use Win32::OLE ('in');
use Sys::Hostname;
use Time::Local;
use Win32::Process;
use JSON;


# Debug Only
#use Data::Dumper;

### Command line arguments
usage() if defined $ARGV[0] and $ARGV[0] eq "--help";

my $key             = 'Name';
my $recid           = 'nicrec';
my $cprefix         = 'C:\\Program Files\\Kronometrix\\etc';
my ($l, $v, $h, $V) = 0;
our %Config         = (ServiceName => $recid);

Getopt::Long::Configure('bundling');
my $result = GetOptions (
                "l|logging" => \$l,
                "v|verbose" => \$v,
                "h|help"    => \$h,
                "V|version" => \$V,
                "n|name=s" => \$Config{ServiceName}
                );

usage() if (defined $h || ! $result);
revision() if (defined $V);

# process [[interval [count]]
my ( $interval, $loop_max );
if ( defined $ARGV[0] ) {
    $interval = $ARGV[0];
    $loop_max = defined $ARGV[1] ? $ARGV[1] : 2**32;
    usage() if $interval == 0;
}
else {
    $interval = 1;
    $loop_max = 1;
}

### Variables
my %nics;
my %nstat;
my $stime;                                                # sleep timer
my $nic_old     = {};
my $nic;
my $loop        = 0;                                      # current loop number
my $last_time   = 0;                                      # first counter
my $cf          = 'kronometrix.json';                     # default json config
my $logtime     = '0000';                                 # check 23:59
my $nicwmi      = 'Win32_NetworkAdapterConfiguration';        # NIC Config
my $tcpwmi      = 'Win32_PerfRawData_Tcpip_NetworkInterface'; # TCPIP
$|= 1;                                                        # autoflush

my $verbose = defined $v ? $v : 0;
my $logging = defined $l ? $l : 0;

### MAIN BODY

my @nicstats = qw(
                   PacketsReceivedPerSec BytesReceivedPerSec 
		   PacketsReceivedErrors PacketsReceivedDiscarded 
		   PacketsSentPerSec     BytesSentPerSec 
		   PacketsOutboundErrors PacketsOutboundDiscarded 
		   OutputQueueLength     PacketsPerSec 
		   BytesTotalPerSec      CurrentBandwidth 
		   Timestamp_PerfTime    Frequency_PerfTime 
		   Frequency_Sys100NS    Timestamp_Sys100NS
		  );


my @filter   =   ( 'isatap',
                   'Microsoft Virtual WiFi Miniport Adapter',
		   'Teredo Tunneling Pseudo-Interface',
		   'Reusable ISATAP Interface'
		 );


# set as HIGH
my $curentProcess;

my $pid = Win32::Process::GetCurrentProcessID();

if (Win32::Process::Open($curentProcess, $pid, 0)) {
    $curentProcess->SetPriorityClass(HIGH_PRIORITY_CLASS);
}

# read configuration
my $cdata = open_config($cf);

my ( $blog, $clog, $dlog ) = get_log($cdata);

my $fname = $blog . "\\" . $recid . ".log";
my $fkrd  = $clog . "\\" . $recid . ".krd";

# log, rawlog files
my ($log, $rawlog);

if ($logging) {
    $rawlog = open_file($fkrd);
    $log = open_file($fname);
    write_log ("info: started");
}

# get stats
my $wmi = Win32::OLE->GetObject("winmgmts://./root/cimv2")
    or die "Cannot initialize WMI interface\n";

my $list;

# pre-init default
init_nic();

unless (defined &ContinueRun) {
    *ContinueRun = sub { return 1 };
    *RunningAsService = sub { return 0 };
    Interactive();
}

if (RunningAsService()) {

    # get service sample interval
    $interval = get_ssi($cdata);
    $loop_max = 2**32;

    $rawlog = open_file($fkrd);
    $log = open_file($fname);

    write_log ("info: started");
}


### SUBROUTINES


sub Startup {

    while(ContinueRun()) {

    k_sleep();

    # my $start = [gettimeofday];

    # NIC stats
    %nstat = ();

    $nic = {};

    get_nicstat();

    $nic_old = $nic;

    # end payload
    my $tnow = [gettimeofday];


    # cktime for rotation
    if (RunningAsService()) {
        cktime();
    }


    if ($last_time > 0) {

        putraw($$tnow[0], %nstat); 
	$last_time = $$tnow[0];

    } else { 

        putraw($$tnow[0], %nstat); 

        if (!RunningAsService()) {
            # check count, interval
            last if ++$loop == $loop_max;
        }

	$last_time = $$tnow[0];
	next;
    }

    if (!RunningAsService()) {
        # check count, interval
        last if ++$loop == $loop_max;
    }

    } # while loop

    if (RunningAsService()) {
        write_log ("info: stopped");
    }
}


sub Interactive {

    Install();

    if (( ! defined $h ) and (! defined $V)) {
        Startup();
    }
}


sub Install {

    if (RunningAsService()) {
        # check for proper config file
        if (! defined $cdata) {
            die "Cant install $Config{ServiceName} service, exiting...\n";
        }

        if (! defined $clog ) {
            die "Cant install $Config{ServiceName} service, exiting...\n";
        }
    }

    $Config{DisplayName} = "Kronometrix $Config{ServiceName} Service";
    $Config{Description} = "Kronometrix $recid Service";

    return;
}


sub Remove {
    $Config{ServiceName} = $recid;
    return;
}


# k_sleep - sleeps exact number of usec
#
sub k_sleep {

    my $t = [gettimeofday];
    my $next = (int($t->[0]/$interval) + 1) * $interval;
    my $delta = tv_interval ($t, [$next, 0]);
    usleep($delta * 1_000_000);

    return;
}


sub init_nic {

    $list = $wmi->InstancesOf($tcpwmi)
        or die "Failed to get $tcpwmi instance object\n";

    foreach my $v (in $list) {

        if (!grep { $v->{$key} =~ /$_/i } @filter) {

	    map{$nic_old->{$v->{$key}}->{$_} = $v->{$_} }@nicstats;
	}
    }
}


# get_diff - get delta between samples as a difference
#
sub get_diff {

    my $h1 = shift;
    my $h2 = shift;
    my $p = shift;
    my $delta = 0;
    my $tf    = 0;

    # timestamp
    my $t2 = $h2->{'Timestamp_PerfTime'};
    my $t1 = $h1->{'Timestamp_PerfTime'};

    # data
    my $v2 = $h2->{$p};
    my $v1 = $h1->{$p};
    $delta = $v2 - $v1;

    # frequency
    my $td = $t2 - $t1;
    my $f2 = $h2->{'Frequency_PerfTime'};

    my $r;
    eval {
        $tf = $td / $f2;
        $r  = $delta / $tf;
    };

    if ($@) {
        chomp ($@);
        write_log("$@");
	write_log("v2=$v2 v1=$v1 t2=$t2 t1=$t1");
    }

    $r = 0 if $r < 0;

    # result
    return $r;
}


# get_pct - get delta between samples as a percentage
#
sub get_pct {

    my $h1 = shift;
    my $h2 = shift;
    my $p  = shift;

    my $v2 = $h2->{$p};
    my $v1 = $h1->{$p};
    my $d  = $v2 - $v1;

    # timestamp
    my $t2 = $h2->{'Timestamp_Sys100NS'};
    my $t1 = $h1->{'Timestamp_Sys100NS'};
    my $td = $t2 - $t1;

    my $r;

    eval {
        $r = $d / $td;
    };

    if ($@) {
        chomp ($@);
        write_log("$@");
	write_log("v2=$v2 v1=$v1 t2=$t2 t1=$t1");
    }

    return $r;
}


# get_avg - get the average time it takes to complete an IO
#
sub get_avg {

    my $h1 = shift;
    my $h2 = shift;
    my $p  = shift;
    my $delta = 0;
    my $tf    = 0;

    # timestamp
    my $t2 = $h2->{'Timestamp_Sys100NS'};
    my $t1 = $h1->{'Timestamp_Sys100NS'};
    my $td = $t2 - $t1;

    # frequency
    my $f2 = $h2->{'Frequency_Sys100NS'};

    # data
    my $v2 = $h2->{$p};
    my $v1 = $h1->{$p};
    $delta = $v2 - $v1;

    my $r;

    eval {
       $tf = $td / $f2;
        $r = $tf / $delta;
    };

    if ($@) {
        chomp ($@);
        write_log("$@");
	write_log("v2=$v2 v1=$v1 t2=$t2 t1=$t1");
    }

    $r = 0 if $r < 0;
   
    # result
    return $r;
}


# get_nicstat - returns nic statistics
#
sub get_nicstat {

    # metrics
    my ($rxpkt, $rxkbytes, $rxpkterr,  $rxpktdrop,
        $txpkt, $txkbytes, $txpkterr,  $txpktdrop,
	$ql,    $rxtxpkt,  $rxtxkbytes,$band);


    $list = $wmi->InstancesOf($tcpwmi) or 
        die "Failed to get $tcpwmi instance object\n";

    # map nic stats
    foreach my $v (in $list) {
    
        if (!grep { $v->{$key} =~ /$_/i } @filter) {

            map{$nic->{$v->{$key}}->{$_} = $v->{$_} }@nicstats;
	}
    }

    # get NACs
    my %nac = get_nac();
    #print Dumper(%nacs);


    #print "NICs " . keys(%$ntcp) . ".\n";
    #print Dumper($nictcp);

    for my $k (keys %$nic) {

        #if (exists $nacs{$k} ) {

	# PERF_COUNTER_COUNTER
        $rxpkt = sprintf("%.2f", get_diff( $nic_old->{"$k"}, $nic->{"$k"}, 
		                          'PacketsReceivedPerSec' ) );

	# PERF_COUNTER_COUNTER
        $rxkbytes = sprintf ("%.2f", get_diff( $nic_old->{"$k"}, $nic->{"$k"},
	                                       'BytesReceivedPerSec') / 1024 );

        # PERF_COUNTER_RAWCOUNT 
        $rxpkterr = sprintf ("%d", $nic->{"$k"}->{'PacketsReceivedErrors'} );

        # PERF_COUNTER_RAWCOUNT 
        $rxpktdrop = sprintf ("%d", 
	                      $nic->{"$k"}->{'PacketsReceivedDiscarded'} );

	# PERF_COUNTER_COUNTER
        $txpkt = sprintf("%.2f", get_diff( $nic_old->{"$k"}, $nic->{"$k"}, 
			                  'PacketsSentPerSec' ) );

	# PERF_COUNTER_COUNTER
        $txkbytes = sprintf ("%.2f", get_diff( $nic_old->{"$k"}, $nic->{"$k"},
	                                       'BytesSentPerSec') / 1024 );

        # PERF_COUNTER_RAWCOUNT 
        $txpkterr = sprintf ("%d", $nic->{"$k"}->{'PacketsOutboundErrors'} );

        # PERF_COUNTER_RAWCOUNT 
        $txpktdrop = sprintf ("%d", 
	                      $nic->{"$k"}->{'PacketsOutboundDiscarded'} );

			
        # PERF_COUNTER_RAWCOUNT 
        $ql = sprintf ("%.2f", $nic->{"$k"}->{'OutputQueueLength'} );
       

	# PERF_COUNTER_COUNTER
        # $rxtxpkt   = $rxpkt + $txpkt;
        $rxtxpkt = sprintf ("%.2f", get_diff( $nic_old->{"$k"}, $nic->{"$k"},
	                                      'PacketsPerSec') );

	# PERF_COUNTER_BULK_COUNT
        # $rxtxkbytes= $rxkbytes + $txkbytes;
        $rxtxkbytes = sprintf ("%.2f", get_diff( $nic_old->{"$k"}, 
	                                         $nic->{"$k"},
                                                 'BytesTotalPerSec') / 1024 );

        # PERF_COUNTER_RAWCOUNT 
        $band = sprintf ("%d", $nic->{"$k"}->{'CurrentBandwidth'} );

        my $nicname;

        if (exists $nac{$k}) {

            if ( $k =~ /\_\d+$/ ) {

                my ($l, $r) = $k =~ /^(.*)(_\d+)$/;
	        $l=~s/^\s+//; $l=~s/\s+$//;	
	        $r=~s/^\s+//; $r=~s/\s+$//;	
	        if (exists $nac{$l}) {
		    $nicname = $nac{$l} . $r;
		}

            } else {
            
                $nicname = $nac{$k};

            }
        } else {

            if ( $k =~ /\_\d+$/ ) {
		my ($l, $r) = $k =~ /^(.*)(_\d+)$/;
	        $l=~s/^\s+//; $l=~s/\s+$//;	
	        $r=~s/^\s+//; $r=~s/\s+$//;	
               
	        if (exists $nac{$l}) {
		    $nicname = $nac{$l} . $r;
		}
	    } else { next; }
	}

        $nstat{$k} = "$nicname:$rxpkt:$rxkbytes:$rxpkterr:$rxpktdrop:$txpkt:$txkbytes:$txpkterr:$txpktdrop:$ql:$rxtxpkt:$rxtxkbytes:$band";

    }

    return;
}


# get_nac - get network adapter configuration
#
sub get_nac {

    my @nicids  =  (
                     'WAN Miniport',
	     	     'Microsoft ISATAP Adapter',
		     'RAS Async Adapter',
		     'Microsoft Virtual WiFi Miniport Adapter',
		     'VMware Virtual Ethernet Adapter',
		     'Microsoft Teredo Tunneling Adapter',
		     'Microsoft Kernel Debug Network Adapter',
		     'Hyper-V Virtual Switch Extension Adapter',
		     'Hyper-V Virtual Ethernet Adapter'
                    );

    # get no of NICs
    my $wn = $wmi->InstancesOf($nicwmi)
        or die "Failed to get instance object\n";

    # Network Adapter Configuration
    my %nac;


    foreach my $nic (in $wn) {

        my $desc = $nic->{Description};

	my $svc  = lc $nic->{ServiceName};

        if (!grep { $desc =~ /$_/i } @nicids) {

            # marked, filter /\()
            $desc =~ s/\(/[/g;
	    $desc =~ s/\)/]/g;
	    $desc =~ s/\//_/g;
	    $desc =~ s/\\/_/g;
	    $desc =~ s/\#/_/g;

            $nac{$desc}=$svc;
	}
    }

    return %nac;
}


# print_raw - print krd raw data
#
sub putraw {
    my ($traw, %c)  = @_;

    if (RunningAsService()) {

        for my $k (sort keys %c) {
            printf $rawlog "%s:%s\n",
                $traw, $c{$k};
        }

    } else {
        if ( $logging ) {

            for my $k (sort keys %c) {
                printf $rawlog "%s:%s\n", $traw, $c{$k};
            }

        }

        for my $k (sort keys %c) {
            printf "%s:%s\n", $traw, $c{$k};
        }
    }
}


# cklog - check log directory
#
sub cklog {

    my ($dir) = @_;

    if (defined $dir) {
        if (! -d $dir) {
            die "error: cklog - cannot find $dir directory";
        }
    } else {
        die "error: cklog - cannot find $dir directory";
    }

    return;
}


# open_data - open data file
#

sub open_file {

    my ($file) = @_;
    my $fh;

    if (-f $file) {
        open $fh, "+>>", "$file" or 
	  die "error: open_file - cannot open $file $!";
	seek $fh, 0, 2;
        select ((select ($fh), $| = 1)[0]);

    } else {
        open $fh, "+>", "$file" or 
	  die "error: open_file - cannot open $file $!";
        select ((select ($fh), $| = 1)[0]);

    }

    return $fh;
}



# open_config - open JSON configuration file
#
sub open_config {

    my ($conf) = @_;
    my $json_data;

    {
        local $/;

        # we will parse now the file
	if ( defined $ENV{'KRMX_PREFIX'} ) {
	    if ( -e "$ENV{'KRMX_PREFIX'}/etc/$conf" ) {
	        open my $fh, "<", "$ENV{'KRMX_PREFIX'}/etc/$conf";
	        $json_data = <$fh>;
	        close $fh;
	    } else {
                die "error: open_config - $! $ENV{'KRMX_PREFIX'}/etc/$conf \n";
	    }
	} else {
	    if ( -e "$cprefix\\$conf" ) {
		open my $fh, "<", "$cprefix\\$conf";
		$json_data = <$fh>;
		close $fh;
	    } else { 
	        die "error: open_config - $! $conf \n"; 
	    }
	} 
    }
    
    my $perl_data = JSON->new->utf8->decode($json_data); 
    
    return $perl_data;
}


# get_ssi - get service sample interval
#
sub get_ssi {
    my ($data) = @_;
    my $ssi;

    my $rpref = substr($recid,0,-3);

    my @recs = @{ $data->{'message'} };

    foreach my $rh (@recs) {
        
        next if ( $rh->{'name'} ne $rpref );
	$ssi = $rh->{'sample'};

    }

    $ssi = 60 if (! defined $ssi); 

    return $ssi;
}


# get_log - get log directory information
#
sub get_log {
    my ($data) = @_;

    my $bpath = $data->{'log'}->{'base_path'};
    cklog($bpath);

    my $cpath = $data->{'log'}->{'current_path'};
    cklog($cpath);

    my $dpath = $data->{'log'}->{'daily_path'};
    cklog($dpath);

    return ( $bpath, $cpath, $dpath );
}


# write_log - write log message
#
sub write_log {

    my ($logbuf) = @_;
    my ( $sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst ) =
    localtime(time);

    my $dt = sprintf "%4d-%02d-%02d %02d:%02d:%02d",
                $year + 1900, $mon + 1, $mday, $hour, $min, $sec;

    if (eof $log) {
        print $log "$dt $logbuf\n";
    } else {
        print $log "\n$dt $logbuf";
    }

    return;
}


# cktime - check midnight time
#
sub cktime {

    my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = 
       localtime(time);

    my $tcheck = sprintf ("%02d%02d", $hour, $min);

    my $yesterday = get_yesterday();

    # print "time check: $tcheck";

    if ($tcheck eq $logtime ) {
        # write_log ("info: cktime - start log rotation");
        close ($rawlog);
	my $numkrd = rotate($clog, $dlog, $yesterday);
        # write_log ("info: cktime - end log rotation, files rotated: $numkrd");
        $rawlog = open_file($fkrd);
    }

    return;
}


## 
sub rmkrd {
    my ($file) = @_;

    if ( -e $file ) {
        if (unlink($file) > 0) { return 0; } else { return 1; }
    }

    return;
}


## null the raw data
sub null2krd {

    my($blog, $clog ) = @_;

    opendir(DIR, $clog) or
        die "error: null2krd - Can't open $clog: $!";
    my @files = grep {!/^\.+$/} readdir(DIR);
    close(DIR);

    my @krds;
    foreach my $krd (@files) {
        next if $krd !~ /.*\.krd$/;
        push @krds, $krd;
    }

    foreach my $krdf (@krds) {
        copy("$clog/$krdf", "$blog") or
           die "error: null2krd cannot copy krd file: $krdf $!\n";
         open my $fh, ">", "$clog/$krdf";
         close $fh;
    }

    return;
}


## rotate raw data
sub rotate {

    my($rawdir, $dailydir, $dstamp) = @_;

    opendir(DIR, $rawdir) or
        die "error: rotate - Can't open $rawdir: $!";
    my @files = grep {!/^\.+$/} readdir(DIR);
    close(DIR);

    my $dest = "$dailydir/$dstamp";

    my @krd_files;
    my $p = $recid . ".krd";

    foreach my $krd (@files) {
        next if $krd !~ /^$p$/;
        push @krd_files, $krd;
    }

    my $nkrd = $#krd_files + 1;
    
    if ($verbose) {
        write_log ("info: rotate - copying krd data files: $nkrd");
    }

    my $cnt = 0;
    # check if we have anything to move to daily
    if ( $nkrd > 0 ) {
   
        # make daily target dir
	mkdir $dest if (! -d $dest);

        #unless(mkdir $dest) {
	#    write_log ("warning: rotate - $dstamp dir: $!");
        #}

        foreach my $rawfile (@krd_files) {
            copy("$rawdir/$rawfile","$dest") or
                write_log ("error: rotate - copying previous daily data, $!");

	    # reset to zero
            open my $ftkrd, ">", "$rawdir/$rawfile";
            close $ftkrd;

            $cnt++;
        }
    }

    # return number of raw krd files moved to daily
    return $cnt;
}


## get yesterday
sub get_yesterday {

    my ( $yy, $mm, $dd ) = Today();
    ( $yy, $mm, $dd ) = Add_Delta_Days( $yy, $mm, $dd, -1 );

    # ISO 8601 YYYY-MM-DD
    my $prevdate = sprintf("%d-%02d-%02d", $yy, $mm, $dd);

    # Debug
    # print "PREVDATE: $prevdate \n";

    return $prevdate;
}


# usage - print usage and exit.
#
sub usage {
    print STDERR <<END;
USAGE: nicrec [-lhV] | [interval [count]]
 eg.
  nicrec.exe                # default CLI mode, print per disk stats stdout
  nicrec.exe 1 5            # print per disk stats 5 times, every 1s stdout
  nicrec.exe -l 25          # print per disk stats every 25s stdout, krdlog
  nicrec.exe -install auto  # run as a service, every 60s, default krdlog
  nicrec.exe -remove        # stop and remove the service

 FIELDS:
   #01 timestamp   : seconds since Epoch, time
   #02 nicid       : NIC id

   # rx received, inbound
   #03 rxpkt       : rx packets per sec, rate
   #04 rxkbytes    : rx KB per sec, rate
   #05 rxerr       : rx packets containg errors, rate 
   #06 rxdrop      : rx drop packets, counter

   # tx transmitted, outbound
   #07 txpkt       : tx packets per sec, rate
   #08 txkbytes    : tx KB per sec, rate
   #09 txerr       : tx packets containg errors, rate 
   #10 txdrop      : tx drop packets, counter

   # queue length, throughput
   #11 ql          : length of the output packet queue, counter
   #12 rxtxpkt     : rx+tx packets per second, counter
   #13 rxtxkbytes  : rx+tx KB per second, rate
   #14 band        : current bandwidth in bps, counter

END
    return;
}


# revision - print revision and exit
#
sub revision {
    print STDERR <<END;
nicrec: 1.1.2, 2016-10-20 1235
END
    return;
}
