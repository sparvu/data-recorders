#!/opt/kronometrix/perl/bin/perl
#
# Author          : Shaun Rowland <rowland@interhack.net>
# Created On      : <99/05/10 03:42:52 rowland>
# Last Modified By: $Author: rowland $
# Last Modified On: $Date: 2001/05/27 18:21:21 $
# Update Count    :
# Status          :
#
# $Id: rotatelog,v 1.7 2001/05/27 18:21:21 rowland Exp $

=pod

=head1 NAME

rotatelog - rotates files when they reach a certain trigger size.

=head1 SYNOPSIS

rotatelog [-cdht]

=head1 DESCRIPTION

This is a program to rotate log files.  It can rotate any file listed in
its configuration file.  The file does not necessarily need to be log
file.  This program imitates the C<logrotate> and C<newsyslog> programs
found on Linux and FreeBSD respectively.  I originally wrote this to
make life easier in Solaris.

=head1 OPTIONS

=over

=item B<-c>

Specify the location of the configuration file.  Multiple configuration
files can be separated by commas with no spaces.

=item B<-d>

Turn on debug output.  This is verbose output that shows most of what
C<rotatelog> does.

=item B<-h>

Print the help information.

=item B<-t>

Turn on the test flag.  This causes C<rotatelog> to run as if all files
need rotation, but disallows the actual rotation.  This is most useful
in combination with the B<-d> flag.

=back

=head1 ERRORS

This program will exit if it cannot open its configuration file(s) and if
any of the system calls fail.  This program will also exit if the there
are any syntax errors in the actions section.  Any other configuration
file errors are ignored and a warning is issued.  All error messages are
printed to C<STDERR>.  This program is meant to be run as a cron job so
error messages such as these will be mailed to the owner of the cron
job.  Many times C<rotatelog> is run in the C<root> crontab.

=head1 FILES

The C<rotatelog> program depends upon its configuration file for
information concerning what files to rotate and when to rotate them.
The C<rotatelog.conf> file is located in the C</usr/local/etc> directory
by default.  This location is set in the configuration section of the
source code along with the paths to certain system utility functions.
It is possible to specify a new configuration file via the C<-c> command
line option, and it is also possible to specify multiple configuration
files in this manner as well using the form C<-c file1,file2,file3>.
Note that configuration files that appear later in a multiple
configuration specification can override settings in previous
configuration files.  When installing this program it will be necessary
to check this section of the source code.  Along with specifying the the
files to rotate there is also the ability to specify ownership and mode
of the files after rotation, the number of rotated files to keep, the
compression used or not used on the rotated files, and an auxiliary
action in the form of a shell command to take place when certain files
are rotated.  The C<rotatelog> program is normally run as C<root>.  It
is important that the config file is only writable by C<root> due to the
ability to execute shell commands!

There are three sections in the configuration file.  They can appear in
any order.  Each section is identified by a keyword.  Configuration
information follows the keyword and extends until the next keyword.
Keywords can come in any order and repeat, but it would be best to
follow a simple format such as:

 FILES:

 # File  Trigger  Owner:Group  Mode  Compress  Archive_Limit
 # =========================================================

 /var/log/wtmp      1M   root:wheel  664  none  4
 /var/log/wtmpx     4M   root:wheel  644  none  4
 /var/log/messages  74K  root:wheel  664  Z     5
 /var/log/maillog   60K  root:wheel  664  gz    7


 ACTIONS:

 # Shell Command :file1,file2,file3 ... fileN
 # ==========================================

 rotate1                             : /var/log/wtmp,/var/log/wtmpx
 kill -HUP `cat /var/run/syslog.pid` : /var/log/messages,/var/log/maillog

 NOTIFY:

 # Person to email rotation notification
 # =====================================

 root@localhost

Comment lines must contain a pound sign at the start of the line.  These
comment lines are ignored along with blank lines and lines containing
only whitespace.  In general there can be no leading whitespace on
configuration lines while there can be any amount of whitespace between
elements.

=head2 Files

The files section specifies which files are to be rotated, when they are
to be rotated, what their ownership and modes are to be post rotation,
how many rotated copies are to be retained, and the compression used on
the files once rotated.  The beginning of the files section is noted by
the occurrence of the C<FILES:> keyword.

This information must adhere to the following syntax:

 File  Trigger  Owner:Group  Mode  Compress  Archive_Limit

For example:

 /var/log/wtmp      1M   root:wheel  664  none  4
 /var/log/wtmpx     4M   root:wheel  644  none  4
 /var/log/messages  74K  root:wheel  664  Z     5
 /var/log/maillog   60K  root:wheel  664  gz    7

The fields above can be separated by any amount of whitespace.  The
first field is the full path to the file that requires rotation.  The
second field is the C<trigger>.  The C<trigger> specifies when rotation
is to occur.  The C<trigger> is the maximum size of a file in bytes,
kilobytes, or megabytes.  Bytes can be specified with B or b, kilobytes
with K or k, or megabytes can be specified with M or m.  If a file
listed is found to be larger than the C<trigger> it is rotated.  The
C<owner:group> field specifies who is to own the file once it is
rotated.  The C<mode> is the file permission mode in octal notation of
the rotated file as specified in the chmod(1) manual page.  The mode
does not include the optional first digit of the four digit chmod(1)
octal mode.  The mode is only the simple three digit format shown above.
The C<compression> field specifies the type of compression to use on the
rotated file.  A file can be compressed with C<gzip> (gz), C<compress>
(Z), or not at all (none).  The C<archive limit> field specifies how
many copies of a rotated file to keep.  This number is the highest count
in the rotation scheme.  The rotation count starts at 0 so this is
actually one higher then the total number of files kept.  If the
C<archive limit> were set to 4 for the file C</var/log/wtmp> the maximum
number of archived C<wtmp> files would be 5.  The files would appear in
the C</var/log/> directory as:

 wtmp    <-- the current wtmp file.
 wtmp.0  <-- the first archive of wtmp.
 .
 .
 .
 wtmp.4  <-- the last archive of wtmp.

If the last file of an archive exists, wtmp.4 in the above example, it
is removed during the rotation and the previous archive file wtmp.3 is
renamed accordingly.  All other files are rotated in the same manner
until the current file is reached and rotated.

=head2 Actions

The actions section specifies if any actions are to occur for any of the
rotated files.  The actions section is denoted by the C<ACTIONS:>
keyword.  Sometimes a process must be notified that it must close its
file descriptors and open new ones due to something like a file
rotation.  Many processes will handle this action when the receive a
C<SIGHUP> signal.  Most of the time a C<kill -HUP> on the process will
accomplish this.  One example is C<syslogd>.  We can see that C<syslogd>
has certain files open all of the time by using C<lsof> to inquire about
the status of one of its log files:

 [rowland@darkstar rowland]$ sudo lsof /var/log/messages
 COMMAND PID USER   FD   TYPE   DEVICE SIZE/OFF NODE NAME
 syslogd  99 root    8w  VREG 4,131076     3119  232 /var/log/messages

It is not enough to just move the current file into the archive and
touch a new one for writing.  The C<syslogd> process must be told that a
new file exists and that it is to close the current file descriptor and
open a new one on the same file name (not to keep writing to the file
pointed to by the current file descriptor).  This is what the actions
section does.  The actions section has the following syntax:

 Shell Command : file1, file2, file3, ... fileN
 - or -
 Shell Command : rotate1, rotate2, ... rotateN

For example:

 rotate1                             : /var/log/wtwp, /var/log/wtmpx
 - or -
 kill -HUP `cat /var/run/syslog.pid` : rotate1
 - or -
 kill -HUP `cat /var/run/syslog.pid` : /var/log/messages,/var/log/maillog

You are free to add whitespace around the C<:> and C<,> characters.
This extra whitespace will be ignored.  When the C</var/log/messages>
file is to be rotated it is first moved to a new name, but not
compressed.  The C<syslogd> program will still be writing to this file
even though the name has changed because its file descriptor points to
this location on the filesystem and the file descriptor is still open at
this point.  A new file is touched and its permissions and ownership are
set to the values specified in the files section.  Then the C<SIGHUP>
signal is the sent to C<syslogd>, and it closes the rotated file and
opens the new file that replaces it.  After this is done it is safe to
compress the old file if compression was specified in the files section.

There is also a special action called C<rotate> which allows you to bind
multiple files together for rotation.  All of the files must be present
in the files section so that C<rotatelog> knows how to rotate them.
When one file is rotated then the other files bound with it are rotated
immediately.  The format of C<rotate> is:

 rotateN : file1, file2, ... fileN

The C<rotate> command must be followed by an integer.  This allows for
more than one binding but only for different groups of files.  You may
not leave the integer off.  The C<wtmp> file is a good candidate for
this type of rotation.  When the C<wtmp> file is rotated it is a good
idea to also rotate the C<wtmpx> file.  A binding of:

 rotate1 : /var/adm/wtmp, /var/adm/wtmpx

will rotate both files whenever one of them needs rotation.  When
binding files for rotation in this manner, there is only one way to
associate another action (a normal shell command) to the rotation of the
bound files.  Using the C<rotate> action indicates that all files are to
be rotated at the same time.  If an action is also to occur, we must be
certain that all of the files have begun rotation before executing that
action.  An action on the group of bound files in the C<rotate> group is
specified by using that C<rotate> action as the bound file for the
normal shell command action.  The C<syslogd> example is perfect for
this.  In the C<syslogd> case one would probably want to send C<syslogd>
a C<SIGHUP> signal once all C<syslogd> files have been rotated.  This is
how that is accomplished:

 rotate2                             : /var/log/messages,/var/log/maillog
 kill -HUP `cat /var/run/syslog.pid` : rotate2

This ensures the following steps occur during file rotation:

 1.  Begin rotation on a file.
          - Figure out the archive count of the current file.
          - Rotate old logs up one count, removing the last if necessary.
          - Rotate the current file up one count.
          - Touch a new version of the file.

 2.  Perform any actions on the file.
          - Check rotateN bound files.
                 [if file is in a rotateN group]
                 - Begin any file rotation on the other files in the
                   rotateN bound group.  All other files are put
                   through step #1 at this point.
                 - Perform any normal shell command action associated
                   with this group of rotateN bound files.
                 - Finish rotation of all other files bound in the
                   rotateN group.  This is step #3.
                 - Return.  This causes the original file that triggered
                   this recursion to finish its rotation.
          - Check normal shell command actions.
                 [in this case the file was not in a rotateN group]
                 - Perform the shell command action.
                 - Return.  This moves the file into step #3.

 3.  Finish rotating a file.
          - Compress the previous log file if the file has been specified
            for compression in the files section.
          - Add the file to the list of files which have been rotated.

This process ensures that any files bound together are in the beginning
of file rotation before any shell commands are executed as a result of
this rotation.  Once the shell command action occurs, if there is one,
all of the files finish their rotation.  Due to this flexibility in file
rotation actions, the following rules apply to the actions section:

 1.  A file may appear in only one rotateN group.

 2.  A file may appear in only one normal shell command group.

 3.  A file may not appear in both a rotateN group and a normal shell
     command action.

 4.  A normal shell command may be bound explicitly to a file that is
     not in a rotateN group.

 5.  A normal shell command cannot be bound to a file in a rotateN
     group explicitly.  To bind a shell command to files in a rotateN
     group one must implicitly bind the command to the rotateN action.

If there are no actions to perform when any of the files are rotated
this section may be omitted from the configuration file.  If you rotate
log files written to by C<syslogd> then you will most certainly require
one of the examples above with the appropriate path to your
C<syslogd.pid> file.  If you leave out this step and rotate C<syslogd>
files, C<syslogd> will most certainly NOT be your friend.  If you choose
to bind C<syslogd> files together in a rotateN group, all of the files
will be rotated when one file is rotated.  If you want to define the
action for each file, only when that file is rotated, do not use the
rotateN form of the action.  It all depends on what you wish to do.

=head2 Notify

The notify section specifies who is to receive notification in the event
that any files are rotated.  The notify section is started with the
C<NOTIFY:> keyword.  The notification is sent out via email to the full
email address specified in this section.  This is the simplest section.
The email address is simply listed as in the following example:

 # Person to receive email rotation notification
 # =============================================

 root@localhost

If there is to be no notification this section may be omitted or a value
of "none" may be used.  There can only be one email address in this
section.

=head1 RESTRICTIONS

There can be no leading whitespace on config file lines.  Someday I may
fix that.  The files must be specified with their full paths in all
sections.  This is true in the actions section where you can list an
action for multiple files.  If there are any syntax errors in the
configuration file those lines will be ignored and a warning will be
printed to C<STDERR>.  If this program is run as a cron job this will
result in an email message to the owner of the cron job.  In most cases
this will be C<root>.

=head1 AUTHOR

This piece of code was written by Shaun Rowland (rowland@interhack.net)
mostly during the early hours of the morning.  In my world that is
considered "day" while afternoon is considered "night".  Go figure.

Copyright 1999, 2000, 2001 Interhack Corporation.  All rights reserved.

=head1 HISTORY

$Log: rotatelog,v $
Revision 1.7  2001/05/27 18:21:21  rowland
Added hostname information.

Revision 1.6  2001/05/23 15:10:48  rowland
Removed history stuff that killed pod2latex.

Revision 1.5  2001/05/23 15:04:47  rowland
Fixed a bug where extra whitespace at the end of an ACTIONS line would cause
the file eq check file at the end of do action() to fail.  Doh!  Now we
are good to go.

Revision 1.4  2001/05/19 21:23:32  rowland
Updated the following in logrotate 1.3:

	* Added the -c and -h command line options.
	* Added the B and b trigger size specification.
	* Changed the release Makefile to create installation directories if
	  they do not already exist.

Revision 1.3  2001/04/22 23:01:36  rowland
Updated perldoc and config file to better reflect reality in rotating
syslogd files.  You wouldn not normally put these files in a rotateN group
and then define an action for that group because this would cause all of
the files to be rotated when just one of them is rotated.  You could do
this if you wanted, but it makes a perfect example.  Better examples will
follow later, but the examples here should better reflect reality.

Revision 1.2  2001/04/22 22:45:25  rowland
Added more actions section error checking and cleaned up the default settings.

Revision 1.1.1.1  2001/04/22 21:58:26  rowland
The rotatelog program was designed to rotate files and perform actions on
those files once rotated if desired.  This program began its life as
logrotate.  I changed the name so it would not be confused with the GNU
logrotate program.  This version includes improved code for handling
rotateN bound files and actions on those bound files (in other words it
now works properly).

=cut

use strict;

#####
#
# Begin configuration section.
#
#####

# Solaris path settings.
my $compress = "/usr/bin/compress";
my $gzip = "/usr/bin/gzip";
my $sendmail = "/usr/lib/sendmail";
my $hostname = "/usr/bin/hostname";

# FreeBSD path settings.
#my $compress = "/usr/bin/compress";
#my $gzip = "/usr/bin/gzip";
#my $sendmail = "/usr/sbin/sendmail";
#my $hostname = "/bin/hostname";

# The default configuration file.
my $default_config = "/opt/sdr/etc/rotatelog.conf";

#####
#
# End configuration section.
#
#####

my(%files, %actions, %ignore, %rotateN, %shell);
my(@rotated_files, @check_files, @config_files);
my $mode = "";
my $notify = 0;
my $found_error = 0;
my($keyword, $file, $trigger, $owner_group, $f_mode, $compression, $errors);
my($shell_command, $size, $archive_limit, $uid, $gid, $debug, $test, $count);
my($config, $prev_op, $config_file, $temp_file);

# Search for -d (debug) and -t (test) command line arguments.  Yes, I know
# about Getopt::Std, etc.
$debug = 0;
$test = 0;
$config = 0;

foreach (@ARGV) {
  if ($_ eq "-d") {
    $debug = 1;
  } elsif ($_ eq "-t") {
    $test = 1;
  } elsif ($_ eq "-c") {
    $config = 1;
  } elsif ($_ eq "-h") {
    usage();
    exit(0);
  } elsif ($prev_op ne "-c") {
    usage();
    exit(1);
  }

  $prev_op = $_;
}

debug("debug  = $debug\n");
debug("test   = $test\n");
debug("config = $config\n");

# If config file information was specified, grab this information.
if ($config) {
  for ($count = 0; $count <= $#ARGV; $count++) {
    if ($ARGV[$count] eq "-c") {
      if ($#ARGV < $count + 1) {
	usage();
	exit(1);
      }

      @config_files = split(/,/, $ARGV[$count + 1]);
      last;
    }
  }
} else {
  @config_files = ($default_config);
}

debug("config_files = @config_files\n");

die "Wrong path to $compress or no execute permission.\n"
  unless (-x "$compress");
die "Wrong path to $gzip or no execute permission.\n" unless (-x "$gzip");
die "Wrong path to $sendmail or no execute permission.\n"
  unless (-x "$sendmail");
die "Wrong path to $hostname or no execute permission.\n"
  unless (-x "$hostname");

#####
#
# Gather configuration file data.
#
#####

foreach $config_file (@config_files) {
  open(CONF, "<$config_file") or die "Cannot open config file: $!";

  while (<CONF>) {
    chomp;

    # Ignore comments and blank lines.  Comments must have a '#' at the 
    # beginning of the line.
    next if (/^\#/ || /^\s*$/);

    # Look for keywords that specify what mode we are in.  There are three
    # keywords.  The first is FILES: and it lists what files we want to rotate.
    # The second is ACTIONS: which list shell commands to execute if certain
    # files are rotated.  The third is NOTIFY: which has the email address of
    # the user to notify if logs were rotated.  Each keyword sets what mode we
    # are in and can occur at any place in the config file.  You can have
    # multiple sections defined, but it would be a bad idea to redefine an
    # action as the last one encountered will be what is defined to be carried
    # out.  There must be keywords in the config file or we will not do
    # anything.
    if (/FILES:/) {
      $mode = "files";
      next;
    } elsif (/ACTIONS:/) {
      $mode = "actions";
      next;
    } elsif (/NOTIFY:/) {
      $mode = "notify";
      next;
    }

    if ($mode eq "files") {
      ($file, $trigger, $owner_group, $f_mode, $compression, $archive_limit)
	= split(/\s+/);

      # Do syntax checking.  Syntax errors are ignored.  Mail will be sent to
      # the user running this from cron, usually root, if this happens.
      unless (-f $file) {
	warn "ERROR: File does not exist for config line:\n";
	warn "$_\n";
	warn "Ignoring line...\n\n";
	next;
      }

      unless ($trigger =~ /^\d+[BbKkMm]$/ ||
	      $trigger =~ /^\d+\.\d+[BbKkMm]$/) {
	warn "SYNTAX ERROR: trigger = $trigger for config line:\n";
	warn "$_\n";
	warn "Acceptable values are \"number[B|b|K|k|M|m]\"\n";
	warn "Ignoring line...\n\n";
	next;
      }

      unless ($owner_group =~ /^\w+:\w+$/) {
	warn "SYNTAX ERROR: owner_group = $owner_group for config line:\n";
	warn "$_\n";
	warn "Acceptable values are owner:group as in chown(1).\n";
	warn "Ignoring line...\n\n";
	next;
      }

      unless ($f_mode =~ /[0-7]{3}/) {
	warn "SYNTAX ERROR: mode = $f_mode for config line:\n";
	warn "$_\n";
	warn "Acceptable values are the three digit octal permission modes in chmod(1).\n";
	warn "Ignoring line...\n\n";
	next;
      }

      unless ($compression =~ /^(gz|Z|none)$/) {
	warn "SYNTAX ERROR: compression = $compression for config line:\n";
	warn "$_\n";
	warn "Acceptable values are \"gz\" and \"Z\" for gzip and compress or \"none\".\n";
	warn "Ignoring line...\n\n";
	next;
      }

      unless ($archive_limit =~ /^\d+$/) {
	warn "SYNTAX ERROR: archive limit = $archive_limit for config line:\n";
	warn "$_\n";
	warn "Acceptable value is an integer representing the number of rotated files to keep.\n";
	warn "Ignoring line...\n\n";
	next;
      }

      #####
      #
      # Data Structure
      # ==============
      #
      # The %files data structure contains all the configuration information
      # about which files to rotate.  The structure is a simple hash of an
      # array of the following format:
      #
      # $files{file} --> (trigger, owner:group, mode, compression,
      #                   archive limit)
      #
      #####

      $files{$file} = [ ($trigger, $owner_group, $f_mode,
			 $compression, $archive_limit) ];
      debug("Found config info for file: $file\n");
      debug("\ttrigger       = $trigger\n");
      debug("\towner_group   = $owner_group\n");
      debug("\tf_mode        = $f_mode\n");
      debug("\tcompression   = $compression\n");
      debug("\tarchive_limit = $archive_limit\n");
    } elsif ($mode eq "actions") {
      # The \s*:\s* allows whitespace around the colon.  Since I use the name
      # of the command and files as key/value pairs, this whitespace is
      # important.  By splitting in this way I can allow for better formatting
      # of the config file.  The same is true for the files in each like with
      # respect to the comma delimiter, although I would never do that :-)
      # The first thing done here is to remove any extra whitespace on the end
      # of the line.  This causes a subtle error where the check_file will not
      # match the real name of the file due to the extra space at the end!
      s/\s*$//;
      ($shell_command, @check_files) = split(/\s*:\s*/);
      @check_files = split(/\s*,\s*/, $check_files[0]);
      debug("Found action:\n");
      debug("\tshell_command = $shell_command\n");
      debug("\tcheck_files   = @check_files\n");

      #####
      #
      # Data Structure
      # ==============
      #
      # The %actions data structure consists of a simple hash of an array built
      # in the following manner:
      #
      # %actions{shell command string} --> (file1, file2, file3 ... fileN)
      #
      # If any of the files in the array pointed to by the "shell command
      # string" key are rotated, the command is carried out.  The action will
      # be done once for each of those files when they are rotated.
      #
      #####

      $actions{$shell_command} = [ @check_files ];
    } elsif ($mode eq "notify") {
      # This is the email address of the person to notify when log files are
      # actually rotated.  The value is an email address or "none".  If the
      # value is none $notify is 0 (which is what it is defined as by default).
      unless (/none/) {
	$notify = $_;
	debug("Found notify:\n");
	debug("\tnotify = $notify\n");
      }
    }
  }

  close(CONF);
}

#####
#
# Check the actions data structure.  These are the ACTIONS rules:
#
# 1.  A file may appear in only one rotateN group.
# 2.  A file may appear in only one normal shell command group.
# 3.  A file may not appear in both a rotateN group and a normal shell
#     command action.
# 4.  A normal shell command may be bound explicitly to a file that is
#     not in a rotateN group.
# 5.  A normal shell command cannot be bound to a file in a rotateN
#     group explicitly.  To bind a shell command to files in a rotateN
#     group one must implicitly bind the command to the rotateN action.
#
# The most important rule here is that if one wants to bind a shell command
# to a rotateN group, it MUST be bound to the name of the rotateN group and
# NOT one of the files in that group.  The other rules are important, but
# this rule is the one that caused this subroutine to be written!
#
#####

foreach $shell_command (keys(%actions)) {
  # Check to make sure that files do not appear in more than one rotateN
  # section.  Also make sure that any files specified here are in the
  # files section.
  if ($shell_command =~ /rotate\d+/) {
    @check_files = @{$actions{$shell_command}};

    foreach $file (@check_files) {
      unless (defined($rotateN{$file})) {
	$rotateN{$file} = 1;
      } else {
	$found_error = 1 unless ($found_error);
	$errors .= "$file defined more than once in a rotateN action.\n";
      }

      unless (defined($files{$file})) {
	$found_error = 1 unless ($found_error);
	$errors .= "$file is in a rotateN action, but not in the files ";
	$errors .= "section.\n";
      }
    }
  }
}

foreach $shell_command (keys(%actions)) {
  # Check to make sure that files do not appear in more than one normal shell
  # command action.  Also make sure any files specified here are in the
  # files section.
  unless ($shell_command =~ /rotate\d+/) {
    @check_files = @{$actions{$shell_command}};

    foreach $file (@check_files) {
      unless (defined($shell{$file})) {
	$shell{$file} = 1;
      } else {
	$found_error = 1 unless ($found_error);
	$errors .= "$file defined more than once in a normal shell action.\n";
      }

      unless (defined($files{$file}) || $file =~ /rotate\d+/) {
	$found_error = 1 unless ($found_error);
	$errors .= "$file is in a shell command action, but not in the files ";
	$errors .= "section.\n";
      }
    }
  }
}

foreach $file (keys(%shell)) {
  # Check to make sure a file does not appear in a normal shell action and a
  # rotateN action.
  foreach $temp_file (keys(%rotateN)) {
    if ($file eq $temp_file) {
      $found_error = 1 unless ($found_error);
      $errors .= "$file defined in rotateN and shell action.\n";
    }
  }
}

die $errors if ($found_error);

# No sense of doing this if debug is false.
if ($debug) {
  debug("\nFinished parsing config file.\n");
  debug("Built the following data structures:\n");
  debug("\nfiles:\n");
  debug("------\n");

  foreach $file (keys(%files)) {
    debug("$file\n");
    debug("\t@{$files{$file}}\n");
  }

  debug("\nactions:\n");
  debug("--------\n");

  foreach $shell_command (keys(%actions)) {
    debug("$shell_command\n");
    debug("\t@{$actions{$shell_command}}\n");
  }

  debug("\nnotify:\n");
  debug("-------\n");
  debug("$notify\n");
}

#####
#
# Process data structures.
#
#####

debug("\nProcessing data structures.\n");

foreach $file (keys %files) {
  debug("\nProcessing file: $file\n\n");
  # Don't process this file if ignored.  This structure dynamically grows
  # from the special rotateN actions.  The rotateN files are all done at
  # the same time, so if one has already been rotated there is no need
  # to do it again if it matched its trigger on this run as well.  If we
  # didn't ignore it there is a possibility that it would be rotated twice.
  if ($ignore{$file}) {
    debug("Ingoring file...\n");
    next;
  }

  ($trigger, $owner_group, $f_mode, $compression, $archive_limit) =
    @{$files{$file}};

  if ($trigger =~ /[Mm]$/) {
    chop $trigger;
    $trigger *= 1048576;
  } elsif ($trigger =~ /[Kk]$/) {
    chop $trigger;
    $trigger *= 1024;
  } elsif ($trigger =~ /[Bb]$/) {
    chop $trigger;
  }

  $size = (stat $file)[7];

  if ($size >= $trigger || $test) {
    rotate_file_begin($file, $owner_group, $f_mode, $compression,
		      $archive_limit);
    rotate_file_end($file);
  }
}

# Send notification email if requested.
if ($notify && @rotated_files) {
  debug("\nSending notification email.\n");
  # Figure out where we are running this program.
  $hostname = `$hostname`;
  chomp($hostname);

  if ($test) {
    debug("[test: email not sent from $hostname]\n");
    exit 0;
  }

  open(MAIL, "|$sendmail -t") or die "cannot open sendmail: $!";
  print MAIL "To: $notify\n";
  print MAIL "Subject: Log file rotation results.\n";
  print MAIL "\n";
  print MAIL "The following files were rotated on $hostname:\n\n";

  foreach $file (@rotated_files) {
    print MAIL "$file\n";
  }

  close MAIL;
}

#####
#
# Begin rotating a file.  This subroutine rotates a file up to the point
# where an action can be done on the file.  This is necessary because a file
# can be compressed, but we do not want to compress the file before an action
# is done on the file because some process (like syslogd) might still have the
# file open even though it has been renamed.  Normally this compression would
# not have to be separated out into a new subroutine, but since we can bind
# files together (resulting in recursion) this is necessary.
#
#####

sub rotate_file_begin {
  my($file, $owner_group, $f_mode, $compression, $archive_limit) = @_;
  my $current_count = 0;
  my $next;

  debug("rotate_file_begin($file, $owner_group, $f_mode, $compression, ");
  debug("$archive_limit)\n");
  # Check to see that rotation has taken place.  If not, there is no need to
  # check the state of rotation as there has never been any at this time.
  if (-f "$file.0" || -f "$file.0.$compression") {
    # Find the current state of file rotation.
    while ($current_count <= $archive_limit) {
      if ($compression eq "none") {
        last unless (-f "$file.$current_count");
      } else {
        last unless (-f "$file.$current_count.$compression");
      }

      $current_count++;
    }
  }

  # This is the number of the highest archive file.  If messages.5.gz is the
  # last archive file, this number will be 5.  Note, there are actually 6
  # files because the first archived file is messages.0.gz.
  $current_count--;

  # In this case we are at the archive limit and the last file needs to be
  # deleted.
  if ($current_count == $archive_limit) {
    if ($compression eq "none") {
      debug("unlink $file.$current_count\n");

      unless ($test) {
	unlink "$file.$current_count"
	  or die "Cannot unlink $file.$current_count: $!";
      } else {
	debug("[test: file not unlinked]\n");
      }
    } else {
      debug("unlink $file.$current_count.$compression\n");

      unless ($test) {
	unlink "$file.$current_count.$compression"
	  or die "Cannot unlink $file.$current_count.$compression: $!";
      } else {
	debug("[test: file not unlinked]\n");
      }
    }

    $current_count--;
  }

  # Rotate all files up one count.
  while ($current_count >= 0) {
    $next = $current_count + 1;

    if ($compression eq "none") {
      debug("rename $file.$current_count $file.$next\n");

      unless ($test) {
	rename "$file.$current_count", "$file.$next"
	  or die "Cannot rename $file.$current_count -> $file.$next: $!";
      } else {
	debug("[test: file not renamed]\n");
      }
    } else {
      debug("rename $file.$current_count.$compression ");
      debug("$file.$next.$compression\n");

      unless ($test) {
	rename "$file.$current_count.$compression", "$file.$next.$compression"
	  or die "Cannot rename $file.$current_count.$compression -> $file.$next.$compression: $!";
      } else {
	debug("[test: file not renamed]\n");
      }
    }

    $current_count--;
  }

  debug("rename $file $file.0\n");

  unless ($test) {
    rename "$file", "$file.0" or die "Cannot rename $file -> $file.0: $!";
  } else {
    debug("[test: file not renamed]\n");
  }

  debug("touch $file\n");

  unless ($test) {
    open(FILE, ">$file") or die "cannot touch $file: $!";
    close(FILE);
  } else {
    debug("[test: file not touched]\n");
  }

  debug("chomd $f_mode $file\n");

  unless ($test) {
    chmod(oct($f_mode), $file) or die "Cannot chmod $file: $!";
  } else {
    debug("[test: file not chomded]\n");
  }

  ($uid, $gid) = split(/:/, $owner_group);
  $uid = (getpwnam($uid))[2];
  $gid = (getgrnam($gid))[2];
  debug("chown $uid:$gid $file\n");

  unless ($test) {
    chown($uid, $gid, $file) or die "Cannot chown $file: $!";
  } else {
    debug("[test: file not chowned]\n");
  }

  # We do all shell actions on a file before finishing the rotation in the
  # subroutine rotate_file_end().
  do_action($file);
}

#####
#
# Finish rotating a file.  Most of this is necessary only if there is
# compression to be applied to a file, but pushing the file onto the
# rotate_files list is necessary in all cases.  At this point any actions
# on this file have been executed and the compression can happen on the
# new rotated filename.
#
#####

sub rotate_file_end {
  my $ret;
  my $file = $_[0];
  my $compression = @{$files{$file}}[3];
  debug("rotate_file_end($file)\n");
  debug("[using $compression compression]\n");

  if ($compression eq "gz") {
    debug("$gzip -f $file.0\n");

    unless ($test) {
      $ret = system("$gzip -f $file.0");
      die "Cannot gzip -f $file.0: $!" unless ($ret/256 == 0);
    } else {
      debug("[test: file not gzipped]\n");
    }
  } elsif ($compression eq "Z") {
    debug("$compress -f $file.0\n");

    unless ($test) {
      $ret = system("$compress -f $file.0");
      die "Cannot compress -f $file.0: $!" unless ($ret/256 == 0);
    } else {
      debug("[test: file not compressed]\n");
    }
  }

  push @rotated_files, $file;
}

#####
#
# Perform an action on a file.
#
#####

sub do_action {
  my $ret;
  my @bound_files;
  my $file = $_[0];
  my($shell_command, $check_file, $skip);

  debug("\tdo_action($file)\n");

  #####
  #
  # It is extremely important to process all rotateN actions first. This
  # ensures that files which are bound together are all rotate before the
  # shell command on the rotateN group is executed.  If the file is not in
  # a rotateN group we then proceed to checking the normal shell commands.
  #
  #####

  debug("\tChecking rotateN actions first.\n");

  foreach $shell_command (keys %actions) {
    if ($shell_command =~ /rotate\d+/) {
      debug("\tIn $shell_command action.\n");
      # In this case we have files which are bound together in their rotation.
      # This means that if one is rotated, they are all rotated.  If this
      # happens we get into a bit of recursion.  First we save the list of
      # files bound together into @bound_files.  This action is then deleted
      # from %actions.  Then we call rotate_file() with the files that are not
      # the current one.  These files are added to the %ignore data structure
      # so that they will not be processed by the main program again.  If the
      # current file is in a rotateN group, all of the rotateN files are
      # rotated then the action for the rotateN group (if any) is executed.
      # The normal operation of rotate_file() is still in effect here, so the
      # files are actually "1/2 rotated", the action is done, and finally all
      # of the file rotations complete.  Ah, the beauty of recursion.
      @bound_files = @{$actions{$shell_command}};

      # Check to see if the current file is a member of this bound group.  If
      # it is not then skip to the next action entry!!!
      $skip = 1;

      foreach $check_file (@bound_files) {
        if ($file eq $check_file) {
          $skip = 0;
          last;
        }
      }

      # If we skip this action check the others and DO NOT GO FURTHER.
      if ($skip) {
	debug("\tThis file is not in this group: skipping to next.\n");
	next;
      }

      debug("\t$file is in $shell_command group: ");
      debug("deleting action for $shell_command\n");
      delete $actions{$shell_command};

      foreach $check_file (@bound_files) {
	# Rotate all of the files bound in the rotateN group which are not
	# the current file.
	unless ($check_file eq $file) {
          # The special rotateN action for this group of files is now gone so
          # it is safe to call rotate_file_begin() on these files bound to the
	  # current one since the next recursive call to do_action() will not
	  # contain this rotateN action (or a normal shell command action) and
	  # this result in no action happening.  If an action is defined on
	  # this rotateN group then that will happen later in this top-level
	  # do_action() call.
	  debug("\tRotating $check_file from $shell_command group.\n");
	  ($trigger, $owner_group, $f_mode, $compression, $archive_limit) =
            @{$files{$check_file}};
          rotate_file_begin($check_file, $owner_group, $f_mode,
			    $compression, $archive_limit);
	  debug("\tBegan rotation on $check_file: adding to ignore list.\n");
          $ignore{$check_file} = 1;
        }
      }

      # Now process any possible shell command action for the current rotateN
      # action.  This is the only way to bind a command to a rotateN group.
      # The other files bound to this one via the rotateN grouping have begun
      # rotation.  It is safe to execute any possible shell command for which
      # all of these rotateN files were dependent.
      debug("\tProcessing possible $shell_command action for $shell_command ");
      debug("group.\n");
      do_action($shell_command);

      #####
      #
      # At this point the following is true:
      #
      # 1.  All of the files in the rotateN group have passed through
      #     rotate_file_begin().
      # 2.  Any associated shell command for a rotateN group has been executed.
      #
      # Now we must finish the file rotation with a call to rotate_file_end()
      # on all of the rotateN files except the current file.  The current file
      # is passed to rotate_file_end() from the main body of code.
      #
      #####

      foreach $check_file (@bound_files) {
	unless ($check_file eq $file) {
	  rotate_file_end($check_file);
	}
      }

      # At this point there is nothing left to check.  All files that needed
      # rotation have been done and all actions on those files are completed.
      # We can do this because a file can only appear in _one_ rotateN action.
      debug("\tLeaving $shell_command action.\n");
      return;
    }
  }

  #####
  #
  # Process regular shell command actions now.  The only way to get here is
  # if the file was not part of a rotateN group.  This is probably the least
  # likely case, but still fairly likely :-)
  #
  #####

  debug("\tChecking normal shell command actions.\n");

  foreach $shell_command (keys %actions) {
    foreach $check_file (@{$actions{$shell_command}}) {
      if ("$file" eq "$check_file") {
	debug("\tProcessing $shell_command for $file.\n");

	unless ($test) {
	  $ret = system("$shell_command");
	  die "Cannot execute $shell_command: $!" unless ($ret/256 == 0);
	} else {
	  debug("\t[test: $shell_command not done]\n");
	}
      }
    }
  }
}

#####
#
# Print debug messages if the debug flag is set.
#
#####

sub debug {
  my $message = $_[0];
  print STDERR $message if ($debug);
}

#####
#
# Print the usage information.
#
#####

sub usage {
  print STDERR "Usage: rotatelog [-cdht]\n\n";
  print STDERR "\t-c\tSpecify a configuration file.  Multiple configuration\n";
  print STDERR "\t\tfiles may be separated by commas (with no spaces).\n";
  print STDERR "\t\t[default: $default_config]\n";
  print STDERR "\t-d\tTurn on debugging output.  This shows everything of\n";
  print STDERR "\t\tinterest that rotatelog does.\n";
  print STDERR "\t-h\tPrint this help information.\n";
  print STDERR "\t-t\tTurn on testing.  This runs as if all of the files\n";
  print STDERR "\t\tneed rotated.  This is most useful with the -d flag.\n";
}
